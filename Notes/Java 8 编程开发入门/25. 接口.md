# 25. 接口

### 1. 接口基本概念
接口属于一种特殊的抽象类，如果一个类定义的时候全部由抽象方法 (abstract) 和全局常量 (static)所组成，那么这种类就称为接口，但是接口是使用interface关键字定义的。

#### 定义接口


```java
interface A4{ //接口
    public static final String MSG = "Hello";  //全局常量
    public abstract void print(); //抽象方法
}
```
由于接口里存在抽象方法，所以接口对象不能使用 `new` 直接实例化。所以接口使用原则如下：
        1.  每一个接口必须定义子类，一个子类可以使用 `implements` 关键字**_实现多个接口_**；
        2.  接口的子类（如果不是抽象类）则必须覆写(overide)接口之中所定义的全部抽象方法；
        3.  利用接口的子类，采用对象的向上转型方式，进行接口对象的实例化操作。

-------
#### 子类实现接口的语法格式：
```java
class 子类 [extends 父类] [implements 接口1，接口2...]{}
```

-------

#### 实现多个接口：
```java
interface A4 { //接口
    public static final String MSG = "Hello";  //全局常量
    public abstract void print(); //抽象方法
}

interface B4 {
    public abstract void get(); //抽象方法
}

abstract class C {
    public abstract void change();
}

class X extends C4 implements A4, B4 {  //实现 A B 两个接口

    @Override
    public void print() {
        System.out.println("override method from interface A");
    }

    @Override
    public void get() {
        System.out.println("overide method from interface B");
    }

    @Override
    public void change() {
        System.out.println("overide method from abstract C");
    }

public class test_demo4 {
    public static void main(String[] args) {
        X x = new X();  //实例化子类对象
        A4 a = x; //向上转型
        B4 b = x;  //向上转型

        a.print();
        b.get();
        x.print();
        x.get();
    }
}
```

##### output
```
override method from interface A
overide method from interface B
override method from interface A
overide method from interface B
```

#### 注意：
* X是A和B的子类，那么X类的对象可以变成A接口或者B接口的对象。
* 从定义结构上讲，A接口和B接口没有任何直接联系，但是两个接口拥有同一个子类X。如下程序，`A a = new X( )` 不要被数据类型和名称所迷惑，最终实例化(new)的是 X。所以即是A的实例也是B的实例。


```java
A a = new X();
B b = (B) a;
b.get( );
System.out.println(a instanceof A);
System.out.println(a instanceof B);
```
##### output
```
overide method from interface B
true
true
```
<br>
* 对于子类而言，除了接口之外，还可能去继承抽象类，所以如果一个子类又要继承抽象类，又要实现接口。 则先使用extends继承抽象，再使用implements实现接口。
* 对于接口而言，里面的组成都是抽象方法和全局常量，所以有时也不写 `abstract` 或 `public static final`, 并且在方法上是否写public结果都是一样的。因为访问接口只有一种使用权限就是public。以下两个接口的定义是完全相同的

```java
//full
interface A{ 
	public static final String INFO="Interface A";
	public abstract void print();
}

//simple
// 定义接口方法的时候就算没写上public,最终也是public.
interface A{
	 String INFO="Interface A";
	 void print();
}
```
* 接口不能继承(extends) 抽象类。
* 在Java之中一个抽象类只能继承(extends)一个抽象的父类。但是一个接口可以使用extends同时继承多个接口。以实现接口的多继承操作。
* Java里，接口的主要功能是解决单继承的局限问题

```java
interface A {
    public void printA();
}

interface B {
    public void printB();
}

interface C extends A, B {  //一个接口继承了多个接口
    public void printC();
}

class X implements C {  //需要覆写所有抽象方法
    public void printA() {
        System.out.println("A");
    }
    public void printB() {
        System.out.println("B");
    }
    public void printC() {
        System.out.println("C");
    }
}
```

#### 内部接口
按照定义来讲interface只能包含抽象方法，和全局常量。而在开发之中,内部类是不会受到限制的,在一个类中可以定义内部类,在一个抽象类之中也可以抽象内部类,在一个接口里面也可以定义内部抽象类或内部接口.

但是从实际的开发来讲用户去定义内部抽象类或内部接口的时候是比较少见的，而且在定义内部接口的时候如果使用了static，表示一个外部接口。
```java
interface A{
	public void funA();
	abstract class B{ //内部抽象类
	       public abstract void funB();
	}
	static interface C{  //外部接口
		public void printC();
	}
}
	
class X inplements A.C{  //X实现了A 内部接口
	       public void funC( ) { }	       
}
```

interface作用：
* 定义不同层之间的操作标准
* 表示一种操作的能力
* 表示将服务器端的远程方法视图暴露给客户端

-------
### 2. 接口的标准定义


